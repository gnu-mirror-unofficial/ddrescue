<html lang="en">
<head>
<title>GNU ddrescue Manual</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-15">
<meta name="description" content="GNU ddrescue Manual">
<meta name="generator" content="makeinfo 4.13+">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">GNU ddrescue Manual</h2>

<p>This manual is for GNU ddrescue (version 1.18-pre6, 1 November 2013).

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>:           Purpose and features of GNU ddrescue
<li><a accesskey="2" href="#Basic-concepts">Basic concepts</a>:         Blocks, clusters, devices, files, sectors, etc
<li><a accesskey="3" href="#Important-advice">Important advice</a>:       Read this or risk losing your data
<li><a accesskey="4" href="#Algorithm">Algorithm</a>:              How ddrescue recovers the data
<li><a accesskey="5" href="#Invoking-ddrescue">Invoking ddrescue</a>:      Command line interface
<li><a accesskey="6" href="#Logfile-structure">Logfile structure</a>:      Detailed format of the logfile
<li><a accesskey="7" href="#Examples">Examples</a>:               A small tutorial with examples
<li><a accesskey="8" href="#Direct-disc-access">Direct disc access</a>:     Bypassing the kernel cache
<li><a accesskey="9" href="#Fill-mode">Fill mode</a>:              Selectively overwriting the output file
<li><a href="#Generate-mode">Generate mode</a>:          Generating an approximate logfile
<li><a href="#Ddrescuelog">Ddrescuelog</a>:            Tool for ddrescue logfiles
<li><a href="#Invoking-ddrescuelog">Invoking ddrescuelog</a>:   Command line interface
<li><a href="#Problems">Problems</a>:               Reporting bugs
<li><a href="#Concept-index">Concept index</a>:          Index of concepts
</ul>

   <pre class="sp">

</pre>
Copyright &copy; 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
2012, 2013 Antonio Diaz Diaz.

   <p>This manual is free documentation: you have unlimited permission
to copy, distribute and modify it.

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Basic-concepts">Basic concepts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p><a name="index-introduction-1"></a>
GNU ddrescue is a data recovery tool. It copies data from one file or
block device (hard disc, cdrom, etc) to another, trying hard to rescue
data in case of read errors.

   <p>The basic operation of ddrescue is fully automatic. That is, you don't
have to wait for an error, stop the program, read the log, restart it
from a new position, etc.

   <p>If you use the logfile feature of ddrescue, the data is rescued very
efficiently, (only the needed blocks are read). Also you can interrupt
the rescue at any time and resume it later at the same point.

   <p>Ddrescue does not write zeros to the output when it finds bad sectors in
the input, and does not truncate the output file if not asked to. So,
every time you run it on the same output file, it tries to fill in the
gaps without wiping out the data already rescued.

   <p>Automatic merging of backups: If you have two or more damaged copies of
a file, cdrom, etc, and run ddrescue on all of them, one at a time, with
the same output file, you will probably obtain a complete and error-free
file. This is so because the probability of having the same area damaged
in all copies is low. Using the logfile, only the needed blocks are read
from the second and successive copies.

   <p>Ddrescue recommends lzip for compression of backups because the lzip
format is designed for long-term data archiving and provides data
recovery capabilities which nicely complement those of ddrescue. 
(Ddrescue fills unreadable sectors with data from other copies, while
lziprecover corrects corrupt sectors with data from other copies). If
the cause of file corruption is damaged media, the combination ddrescue
+ lziprecover is the best option for recovering data from multiple
damaged copies. See <a href="#lziprecover_002dexample">lziprecover-example</a>, for an example.

   <p>Recordable CD and DVD media keep their data only for a finite time
(typically for many years). After that time, data loss develops slowly
with read errors growing from the outer media region towards the inside. 
Just make two (or more) copies of every important CD/DVD you burn so
that you can later recover them with ddrescue.

   <p>Because ddrescue needs to read and write at random places, it only works
on seekable (random access) input and output files.

   <p>If your system supports it, ddrescue can use direct disc access to read
the input file, bypassing the kernel cache.

   <p>Ddrescue also features a "fill mode" able to selectively overwrite parts
of the output file, which has a number of interesting uses like wiping
data, marking bad areas or even, in some cases, "repair" damaged
sectors.

<div class="node">
<a name="Basic-concepts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Important-advice">Important advice</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Basic concepts</h2>

<p><a name="index-basic-concepts-2"></a>
     <dl>
<dt>Block<dd>Any amount of data. A block is described by its starting position and
its size.

     <br><dt>Cluster<dd>Group of consecutive sectors read or written in one go.

     <br><dt>Device<dd>Piece of hardware containing data. Hard disc drives, cdrom drives, USB
pendrives, are devices. /dev/hda, /dev/sdb, are device names.

     <br><dt>File<dd>Files are named units of data which are stored by the operating system
for you to retrieve later by name. Devices and partitions are accessed
by means of their associated file names.

     <br><dt>Partition<dd>Every part in which a device is divided. A partition normally contains a
file system. /dev/hda1, /dev/sdb3, are partition names.

     <br><dt>Recoverable formats<dd>As ddrescue uses standard library functions to read data from the device
being rescued, only mountable device formats can be rescued with
ddrescue. DVDs can be mounted and they can be rescued, "compact disc
digital audio" CDs can't, "video CDs"[1] maybe.<br>
[1] http://en.wikipedia.org/wiki/Video_CD

     <br><dt>Rescue domain<dd>Block or set of blocks to be acted upon (rescued, listed, etc). You can
define it with the options '<samp><span class="samp">--input-position</span></samp>', '<samp><span class="samp">--size</span></samp>' and
'<samp><span class="samp">--domain-logfile</span></samp>'. The rescue domain defaults to the whole input
file or logfile.

     <br><dt>Sector<dd>Hardware block. Smallest accessible amount of data on a device.

   </dl>

<div class="node">
<a name="Important-advice"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Algorithm">Algorithm</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic-concepts">Basic concepts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Using ddrescue safely</h2>

<p><a name="index-using-ddrescue-safely-3"></a>
Ddrescue is like any other power tool. You need to understand what it
does, and you need to understand some things about the machines it does
those things to, in order to use it safely.

   <p>Always use a logfile unless you know you won't need it. Without a
logfile, ddrescue can't resume a rescue, only reinitiate it.

   <p>Never try to rescue a r/w mounted partition. The resulting copy may be
useless.

   <p>Never try to repair a file system on a drive with I/O errors; you will
probably lose even more data.

   <p>If you use a device or a partition as destination, any data stored there
will be overwritten.

   <p>Some systems may change device names on reboot (eg. udev enabled
systems). If you reboot, check the device names before restarting
ddrescue.

   <p>If you interrupt the rescue and then reboot, any partially copied
partitions should be hidden before allowing them to be touched by any
operating system that tries to mount and "fix" the partitions it sees.

<div class="node">
<a name="Algorithm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invoking-ddrescue">Invoking ddrescue</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Important-advice">Important advice</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Algorithm</h2>

<p><a name="index-algorithm-4"></a>
GNU ddrescue is not a derivative of dd, nor is related to dd in any way
except in that both can be used for copying data from one device to
another. The key difference is that ddrescue uses a sophisticated
algorithm to copy data from failing drives causing them as little
additional damage as possible.

   <p>Ddrescue manages efficiently the status of the rescue in progress and
tries to rescue the good parts first, scheduling reads inside bad (or
slow) areas for later. This maximizes the amount of data that can be
finally recovered from a failing drive.

   <p>The standard dd utility can be used to save data from a failing drive,
but it reads the data sequentially, which may wear out the drive without
rescuing anything if the errors are at the beginning of the drive.

   <p>Other programs read the data sequentially but switch to small size reads
when they find errors. This is a bad idea because it means spending more
time at error areas, damaging the surface, the heads and the drive
mechanics, instead of getting out of them as fast as possible. This
behavior reduces the chances of rescuing the remaining good data.

   <p>The algorithm of ddrescue is as follows (the user may interrupt the
process at any point, but be aware that a bad drive can block ddrescue
for a long time until the kernel gives up):

   <p>1) Optionally read a logfile describing the status of a multi-part or
previously interrupted rescue. If no logfile is specified or is empty or
does not exist, mark all the rescue domain as non-tried.

   <p>2) (First phase; Copying) Read the non-tried parts of the input file,
marking the failed blocks as non-trimmed and skipping beyond them, until
all the rescue domain is tried. Slow areas are also skipped and tried
later in additional passes (before trimming). Only non-tried areas are
read in large blocks. Trimming, splitting and retrying are done sector
by sector. Each sector is tried at most two times; the first in this
step as part of a large block read, the second in one of the steps below
as a single sector read.

   <p>3) (Second phase; Trimming) Read forwards one sector at a time from the
leading edge of the largest non-trimmed block, until a bad sector is
found. Then read backwards one sector at a time from the trailing edge
of the same block, until a bad sector is found. For each non-trimmed
block, mark the bad sectors found as bad-sector and mark the rest of
that block as non-split. Repeat until there are no more non-trimmed
blocks.

   <p>4) (Third phase; Splitting) Read forwards one sector at a time from the
center of the largest non-split block, until a bad sector is found. 
Then, if the bad sector found is not the first one tried, read backwards
one sector at a time from the center of the same block, until a bad
sector is found. If the logfile is larger than '<samp><span class="samp">--logfile-size</span></samp>',
read the smallest non-split blocks until the number of entries in the
logfile drops below '<samp><span class="samp">--logfile-size</span></samp>'. Repeat until all remaining
non-split blocks have less than 5 sectors. Then read the remaining
non-split blocks sequentially.

   <p>5) (Fourth phase; Retrying) Optionally try to read again the bad sectors
until the specified number of retry passes is reached. Every bad sector
is tried only once in each pass.

   <p>6) Optionally write a logfile for later use.

   <pre class="sp">

</pre>
Note that as ddrescue splits the failed blocks, making them smaller, the
total error size may diminish while the number of errors increases.

   <p>The logfile is periodically saved to disc, as well as when ddrescue
finishes or is interrupted. So in case of a crash you can resume the
rescue with little recopying.

   <p>Also, the same logfile can be used for multiple commands that copy
different areas of the input file, and for multiple recovery attempts
over different subsets. See this example:

<p class="noindent">Rescue the most important part of the disc first.
<pre class="example">     ddrescue -i0 -s50MiB /dev/hdc hdimage logfile
     ddrescue -i0 -s1MiB -d -r3 /dev/hdc hdimage logfile
</pre>
   <p class="noindent">Then rescue some key disc areas.
<pre class="example">     ddrescue -i30GiB -s10GiB /dev/hdc hdimage logfile
     ddrescue -i230GiB -s5GiB /dev/hdc hdimage logfile
</pre>
   <p class="noindent">Now rescue the rest (does not recopy what is already done).
<pre class="example">     ddrescue /dev/hdc hdimage logfile
     ddrescue -d -r3 /dev/hdc hdimage logfile
</pre>
   <div class="node">
<a name="Invoking-ddrescue"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Logfile-structure">Logfile structure</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Algorithm">Algorithm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Invoking ddrescue</h2>

<p><a name="index-invoking-ddrescue-5"></a><a name="index-options-6"></a><a name="index-usage-7"></a><a name="index-version-8"></a>
The format for running ddrescue is:

<pre class="example">     ddrescue [<var>options</var>] <var>infile</var> <var>outfile</var> [<var>logfile</var>]
</pre>
   <p>ddrescue supports the following options:

     <dl>
<dt>'<samp><span class="samp">-h</span></samp>'<dt>'<samp><span class="samp">--help</span></samp>'<dd>Print an informative help message describing the options and exit.

     <br><dt>'<samp><span class="samp">-V</span></samp>'<dt>'<samp><span class="samp">--version</span></samp>'<dd>Print the version number of ddrescue on the standard output and exit.

     <br><dt>'<samp><span class="samp">-a </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--min-read-rate=</span><var>bytes</var></samp>'<dd>Minimum read rate of good non-tried areas, in bytes per second. If the
read rate falls below this value, ddrescue will skip ahead a variable
amount depending on rate and error histories. The skipped blocks are
tried in additional passes (before trimming) where the minimum read rate
is divided by ten before each pass, until there are no more non-tried
blocks left.

     <p>If <var>bytes</var> is 0 (auto), the minimum read rate is recalculated for
each block as (average_rate&nbsp;/&nbsp;10)<!-- /@w -->. Values above device capabilities
are ignored.

     <br><dt>'<samp><span class="samp">-A</span></samp>'<dt>'<samp><span class="samp">--try-again</span></samp>'<dd>Mark all non-split and non-trimmed blocks inside the rescue domain as
non-tried before beginning the rescue. Try this if the drive stops
responding and ddrescue immediately starts splitting failed blocks when
restarted. If '<samp><span class="samp">--retrim</span></samp>' is also specified, mark all failed blocks
inside the rescue domain as non-tried.

     <br><dt>'<samp><span class="samp">-b </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--sector-size=</span><var>bytes</var></samp>'<dd>Sector (hardware block) size of input device in bytes (usually 512 for
hard discs and 3.5" floppies, 1024 for 5.25" floppies, and 2048 for
cdroms). Defaults to 512.

     <br><dt>'<samp><span class="samp">-B</span></samp>'<dt>'<samp><span class="samp">--binary-prefixes</span></samp>'<dd>Show units with binary prefixes (powers of 1024).<br>
SI prefixes (powers of 1000) are used by default. (See table below).

     <br><dt>'<samp><span class="samp">-c </span><var>sectors</var></samp>'<dt>'<samp><span class="samp">--cluster-size=</span><var>sectors</var></samp>'<dd>Number of sectors to copy at a time. Defaults to 64&nbsp;KiB&nbsp;/&nbsp;sector_size<!-- /@w -->. 
Try smaller values for slow drives. The number of sectors per track (18
or 9) is a good value for floppies.

     <br><dt>'<samp><span class="samp">-C</span></samp>'<dt>'<samp><span class="samp">--complete-only</span></samp>'<dd>Limit rescue domain to the blocks listed in the <var>logfile</var>. Do not
read new data beyond <var>logfile</var> limits. This is useful when reading
from devices of undefined size (like raw devices), when the drive
returns an incorrect size, or when reading from a partial copy. It can
only be used after a first rescue attempt, possibly limited with the
'<samp><span class="samp">--size</span></samp>' option, has produced a complete <var>logfile</var>.

     <br><dt>'<samp><span class="samp">-d</span></samp>'<dt>'<samp><span class="samp">--direct</span></samp>'<dd>Use direct disc access to read from <var>infile</var>, bypassing the kernel
cache. (Open the file with the O_DIRECT flag). Use it only on devices or
partitions, not on regular files. Sector size must be correctly set for
this to work. Not all systems support this.

     <p>If your system does not support direct disc access, ddrescue will warn
you. If the sector size is not correctly set, all reads will result in
errors, and no data will be rescued.

     <br><dt>'<samp><span class="samp">-D</span></samp>'<dt>'<samp><span class="samp">--synchronous</span></samp>'<dd>Use synchronous writes for <var>outfile</var>. (Issue a fsync call after
every write). May be useful when forcing the drive to remap its bad
sectors.

     <br><dt>'<samp><span class="samp">-e [+]</span><var>n</var></samp>'<dt>'<samp><span class="samp">--max-errors=[+]</span><var>n</var></samp>'<dd>Maximum number of error areas allowed before giving up. Defaults to
infinity. If <var>n</var> is preceded by '<samp><span class="samp">+</span></samp>' the number refers to new
error areas found in this run, not counting those already annotated in
the <var>logfile</var>.

     <br><dt>'<samp><span class="samp">-E </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--max-error-rate=</span><var>bytes</var></samp>'<dd>Maximum rate of errors allowed before giving up, in bytes per second. 
Defaults to infinity. The rate being measured is that of actually failed
reads, so the rescue may finish because of this rate being exceeded even
if the total error size (errsize) does not change because the areas
being tried are already marked as errors.

     <br><dt>'<samp><span class="samp">-f</span></samp>'<dt>'<samp><span class="samp">--force</span></samp>'<dd>Force overwrite of <var>outfile</var>. Needed when <var>outfile</var> is not a
regular file, but a device or partition.

     <br><dt>'<samp><span class="samp">-F </span><var>types</var></samp>'<dt>'<samp><span class="samp">--fill-mode=</span><var>types</var></samp>'<dd>Fill the blocks in <var>outfile</var> specified as any of <var>types</var> in
<var>logfile</var>, with data read from <var>infile</var>. <var>types</var> contains
one or more of the status characters defined in the chapter Logfile
structure (see <a href="#Logfile-structure">Logfile structure</a>). See the chapter Fill mode
(see <a href="#Fill-mode">Fill mode</a>) for a complete description of the fill mode.

     <br><dt>'<samp><span class="samp">-G</span></samp>'<dt>'<samp><span class="samp">--generate-mode</span></samp>'<dd>Generate an approximate <var>logfile</var> from the <var>infile</var> and
<var>outfile</var> of the original rescue run. Note that you must keep the
original offset between '<samp><span class="samp">--input-position</span></samp>' and
'<samp><span class="samp">--output-position</span></samp>' of the original rescue run. See the chapter
Generate mode (see <a href="#Generate-mode">Generate mode</a>) for a complete description of the
generate mode.

     <br><dt>'<samp><span class="samp">-i </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--input-position=</span><var>bytes</var></samp>'<dd>Starting position in <var>infile</var>, in bytes. Defaults to 0. In fill mode
it refers to a position in the <var>infile</var> of the original rescue run. 
See the chapter Fill mode (see <a href="#Fill-mode">Fill mode</a>) for details.

     <br><dt>'<samp><span class="samp">-I</span></samp>'<dt>'<samp><span class="samp">--verify-input-size</span></samp>'<dd>Compare the size of <var>infile</var> with the size calculated from the list
of blocks contained in the <var>logfile</var>, and exit with status 1 if they
differ. This is not enabled by default because the size of some devices
can't be known in advance and because the size derived from the
<var>logfile</var> may be incomplete, for example after doing a partial
rescue.

     <br><dt>'<samp><span class="samp">-K </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--skip-size=</span><var>bytes</var></samp>'<dd>Set the initial size to skip on the first read error or slow read. The
value given will be rounded to the next multiple of sector size. The
skip size will be doubled for each read error or slow read until it
reaches 1% of the size of <var>infile</var> or 1 GiB (whichever is smaller),
and reset when good data is found. If ddrescue is having difficulties
skipping away from a large area with scattered errors, or if the device
has large error areas at regular intervals, you can increase the initial
skip size with this option. Valid values range from 64 KiB to 1 GiB. 
Defaults to 64 KiB.

     <br><dt>'<samp><span class="samp">-l </span><var>entries</var></samp>'<dt>'<samp><span class="samp">--logfile-size=</span><var>entries</var></samp>'<dd>During the splitting phase, do not grow logfile beyond this number of
entries. Logfile may be larger if it was larger at startup or if it
became larger during the copying or trimming phases. Defaults to 1000. 
(Each entry is about 26-30 bytes in size).

     <br><dt>'<samp><span class="samp">-L</span></samp>'<dt>'<samp><span class="samp">--loose-domain</span></samp>'<dd>Accept a incomplete synthetic (user fabricated) domain logfile and fill
the gaps with non-tried blocks. The blocks in the logfile must be
strictly ascending and non-overlapping, but they do not need to be
contiguous. This option allows making quick edits to a logfile without
all the size calculations involved in making all data blocks contiguous
again.

     <br><dt>'<samp><span class="samp">-m </span><var>file</var></samp>'<dt>'<samp><span class="samp">--domain-logfile=</span><var>file</var></samp>'<dd>Restrict the rescue domain to the blocks marked as finished in the
logfile <var>file</var>. This is useful for merging partially recovered
images of backups, or if the destination drive fails during the rescue.

     <br><dt>'<samp><span class="samp">-M</span></samp>'<dt>'<samp><span class="samp">--retrim</span></samp>'<dd>Mark all failed blocks inside the rescue domain as non-trimmed before
beginning the rescue. The effect is similar to '<samp><span class="samp">--retry-passes=1</span></samp>',
but the bad sectors are tried in a different order, making perhaps
possible to rescue some of them.

     <br><dt>'<samp><span class="samp">-n</span></samp>'<dt>'<samp><span class="samp">--no-split</span></samp>'<dd>Skip the splitting phase. Avoids spending a lot of time trying to rescue
the most difficult parts of the file.

     <br><dt>'<samp><span class="samp">-N</span></samp>'<dt>'<samp><span class="samp">--no-trim</span></samp>'<dd>Skip the trimming phase. Specially useful in the first parts of a
multi-part rescue.

     <br><dt>'<samp><span class="samp">-o </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--output-position=</span><var>bytes</var></samp>'<dd>Starting position in <var>outfile</var>, in bytes. Defaults to
'<samp><span class="samp">--input-position</span></samp>'. The bytes below <var>bytes</var> aren't touched if
they exist and truncation is not requested. Else they are set to 0.

     <br><dt>'<samp><span class="samp">-O</span></samp>'<dt>'<samp><span class="samp">--reopen-on-error</span></samp>'<dd>Close the input file and then reopen it after every read error and, if
'<samp><span class="samp">--min-read-rate</span></samp>' is set, after every slow read encountered both
during the copying phase (i.e., every time ddrescue skips ahead). Use
this option if you notice a permanent drop in transfer rate after
finding read errors or slow areas. But be warned that most probably the
slowing-down is intentionally caused by the kernel in an attempt to
increase the probability of reading data from the device.

     <br><dt>'<samp><span class="samp">-p</span></samp>'<dt>'<samp><span class="samp">--preallocate</span></samp>'<dd>Preallocate space on disc for <var>outfile</var>. Only space for regular
files can be preallocated. If preallocation succeeds, rescue will not
fail due to lack of free space on disc. If ddrescue can't determine the
size to preallocate, you may need to specify it with some combination of
the '<samp><span class="samp">--input-position</span></samp>', '<samp><span class="samp">--output-position</span></samp>', '<samp><span class="samp">--size</span></samp>',
and '<samp><span class="samp">--domain-logfile</span></samp>' options.

     <br><dt>'<samp><span class="samp">-q</span></samp>'<dt>'<samp><span class="samp">--quiet</span></samp>'<dd>Quiet operation. Suppress all messages.

     <br><dt>'<samp><span class="samp">-r </span><var>n</var></samp>'<dt>'<samp><span class="samp">--retry-passes=</span><var>n</var></samp>'<dd>Exit after given number of retry passes. Defaults to 0. -1 means
infinity. Every bad sector is tried only once in each pass. To retry bad
sectors detected on a previous run, you must specify a non-zero number
of retry passes.

     <br><dt>'<samp><span class="samp">-R</span></samp>'<dt>'<samp><span class="samp">--reverse</span></samp>'<dd>Reverse direction of copying, retrying, and the sequential part of
splitting, running them backwards from the end of the input file.

     <br><dt>'<samp><span class="samp">-s </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--size=</span><var>bytes</var></samp>'<dd>Maximum size of the input data to be copied, in bytes. If ddrescue can't
determine the size of the input device, you may need to specify it with
this option. Note that this option specifies the size of the input data
to be copied, not the size of the resulting <var>outfile</var>. So, for
example, the following command creates an <var>outfile</var> 300 bytes long,
but only writes data on the last 200 bytes:

     <pre class="example">          ddrescue -i 100 -s 200 infile outfile logfile
</pre>
     <br><dt>'<samp><span class="samp">-S</span></samp>'<dt>'<samp><span class="samp">--sparse</span></samp>'<dd>Use sparse writes for <var>outfile</var>. (The blocks of zeros are not
actually allocated on disc). May save a lot of disc space in some cases. 
Not all systems support this. Only regular files can be sparse.

     <br><dt>'<samp><span class="samp">-t</span></samp>'<dt>'<samp><span class="samp">--truncate</span></samp>'<dd>Truncate <var>outfile</var> to zero size before writing to it. Only works for
regular files, not for drives or partitions.

     <br><dt>'<samp><span class="samp">-T </span><var>interval</var></samp>'<dt>'<samp><span class="samp">--timeout=</span><var>interval</var></samp>'<dd>Maximum time since last successful read allowed before giving up. 
Defaults to infinity. <var>interval</var> is a rational number (like 1.5 or
1/2) optionally followed by one of '<samp><span class="samp">s</span></samp>', '<samp><span class="samp">m</span></samp>', '<samp><span class="samp">h</span></samp>' or
'<samp><span class="samp">d</span></samp>', meaning seconds, minutes, hours and days respectively. If no
unit is specified, it defaults to seconds.

     <br><dt>'<samp><span class="samp">-v</span></samp>'<dt>'<samp><span class="samp">--verbose</span></samp>'<dd>Verbose mode. Further -v's (up to 4) increase the verbosity level.

     <br><dt>'<samp><span class="samp">-w</span></samp>'<dt>'<samp><span class="samp">--ignore-write-errors</span></samp>'<dd>Make fill mode ignore write errors. This is useful to avoid ddrescue
exiting because of new errors developing while wiping the good sectors
of a failing drive. Fill mode normally writes to <var>outfile</var> one
cluster at a time. With this option, after the first write error is
found in an area, the rest of that area is filled sector by sector.

     <br><dt>'<samp><span class="samp">-x </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--extend-outfile=</span><var>bytes</var></samp>'<dd>Extend the size of <var>outfile</var> to make it at least <var>bytes</var> long. 
If the size of <var>outfile</var> is already equal or longer than <var>bytes</var>
then this option does nothing. Use this option to guarantee a minimum
size for <var>outfile</var>. Only regular files can be extended.

     <br><dt>'<samp><span class="samp">-1 </span><var>file</var></samp>'<dt>'<samp><span class="samp">--log-rates=</span><var>file</var></samp>'<dd>Log rates and error sizes every second in <var>file</var>. Every time the
screen is updated with new details, some of those details (time, input
position, current and average rates, number of errors and error size)
are written to <var>file</var> in a format usable by plotting utilities like
gnuplot. This allows a posterior analysis of the drive to see if it has
any weak zones (areas where the transfer rate drops well below the
sustained average).

     <br><dt>'<samp><span class="samp">-2 </span><var>file</var></samp>'<dt>'<samp><span class="samp">--log-reads=</span><var>file</var></samp>'<dd>Log all read operations in <var>file</var>. Every read attempt and its result
(position, size, copied size and error size) is written to <var>file</var>. A
line is also written at the beginning of each phase (copying, trimming,
splitting and retrying). Finally, a line with a time mark is written
every second (unless the read takes more time). Use this option with
caution because <var>file</var> may become very large very quickly. Use
'<samp><span class="samp">lzip -7</span></samp>' to compress <var>file</var> if you need to store or transmit
it.

   </dl>

   <p>Numbers given as arguments to options (positions, sizes, rates, etc) may
be followed by a multiplier and an optional '<samp><span class="samp">B</span></samp>' for "byte".

   <p>Table of SI and binary prefixes (unit multipliers):

   <p><table summary=""><tr align="left"><td valign="top">Prefix </td><td valign="top">Value               </td><td valign="top">| </td><td valign="top">Prefix </td><td valign="top">Value
<br></td></tr><tr align="left"><td valign="top"></td><td valign="top"></td><td valign="top">| </td><td valign="top">s  </td><td valign="top">sectors
<br></td></tr><tr align="left"><td valign="top">k </td><td valign="top">kilobyte  (10^3 = 1000)  </td><td valign="top">| </td><td valign="top">Ki </td><td valign="top">kibibyte (2^10 = 1024)
<br></td></tr><tr align="left"><td valign="top">M </td><td valign="top">megabyte  (10^6)         </td><td valign="top">| </td><td valign="top">Mi </td><td valign="top">mebibyte (2^20)
<br></td></tr><tr align="left"><td valign="top">G </td><td valign="top">gigabyte  (10^9)         </td><td valign="top">| </td><td valign="top">Gi </td><td valign="top">gibibyte (2^30)
<br></td></tr><tr align="left"><td valign="top">T </td><td valign="top">terabyte  (10^12)        </td><td valign="top">| </td><td valign="top">Ti </td><td valign="top">tebibyte (2^40)
<br></td></tr><tr align="left"><td valign="top">P </td><td valign="top">petabyte  (10^15)        </td><td valign="top">| </td><td valign="top">Pi </td><td valign="top">pebibyte (2^50)
<br></td></tr><tr align="left"><td valign="top">E </td><td valign="top">exabyte   (10^18)        </td><td valign="top">| </td><td valign="top">Ei </td><td valign="top">exbibyte (2^60)
<br></td></tr><tr align="left"><td valign="top">Z </td><td valign="top">zettabyte (10^21)        </td><td valign="top">| </td><td valign="top">Zi </td><td valign="top">zebibyte (2^70)
<br></td></tr><tr align="left"><td valign="top">Y </td><td valign="top">yottabyte (10^24)        </td><td valign="top">| </td><td valign="top">Yi </td><td valign="top">yobibyte (2^80)
   <br></td></tr></table>

   <pre class="sp">

</pre>
Exit status: 0 for a normal exit, 1 for environmental problems (file not
found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or
invalid input file, 3 for an internal consistency error (eg, bug) which
caused ddrescue to panic.

<div class="node">
<a name="Logfile-structure"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Examples">Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Invoking-ddrescue">Invoking ddrescue</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Logfile structure</h2>

<p><a name="index-logfile-structure-9"></a>
The logfile is a text file easy to read and edit. It is formed by three
parts, the heading comments, the status line, and the list of data
blocks. Any line beginning with '<samp><span class="samp">#</span></samp>' is a comment line.

   <p>NOTE: Logfiles generated by a version of ddrescue prior to 1.6 lack the
status line. If you want to use an old logfile with ddrescue 1.6 or
later, you will have to insert a line like '<samp><span class="samp">0 +</span></samp>' at the beginning
of the logfile.

   <p>The heading comments contain the version of ddrescue and the command
line used to create the logfile. They are intended as information for
the user.

   <p>The first non-comment line is the status line. It contains a
non-negative integer and a status character. The integer is the position
being tried in the input file. The status character is one of these:

   <p><table summary=""><tr align="left"><td valign="top">Character </td><td valign="top">Meaning
<br></td></tr><tr align="left"><td valign="top">'?'       </td><td valign="top">copying non-tried blocks
<br></td></tr><tr align="left"><td valign="top">'*'       </td><td valign="top">trimming non-trimmed blocks
<br></td></tr><tr align="left"><td valign="top">'/'       </td><td valign="top">splitting non-split blocks
<br></td></tr><tr align="left"><td valign="top">'-'       </td><td valign="top">retrying bad sectors
<br></td></tr><tr align="left"><td valign="top">'F'       </td><td valign="top">filling specified blocks
<br></td></tr><tr align="left"><td valign="top">'G'       </td><td valign="top">generating approximate logfile
<br></td></tr><tr align="left"><td valign="top">'+'       </td><td valign="top">finished
   <br></td></tr></table>

   <p>The blocks in the list of data blocks must be contiguous and
non-overlapping.

   <p>Every line in the list of data blocks describes a block of data. It
contains 2 non-negative integers and a status character. The first
integer is the starting position of the block in the input file, the
second integer is the size (in bytes) of the block. The status character
is one of these:

   <p><table summary=""><tr align="left"><td valign="top">Character </td><td valign="top">Meaning
<br></td></tr><tr align="left"><td valign="top">'?'       </td><td valign="top">non-tried block
<br></td></tr><tr align="left"><td valign="top">'*'       </td><td valign="top">failed block non-trimmed
<br></td></tr><tr align="left"><td valign="top">'/'       </td><td valign="top">failed block non-split
<br></td></tr><tr align="left"><td valign="top">'-'       </td><td valign="top">failed block bad-sector(s)
<br></td></tr><tr align="left"><td valign="top">'+'       </td><td valign="top">finished block
   <br></td></tr></table>

<p class="noindent">And here is an example logfile:

<p class="noindent"># Rescue Logfile. Created by GNU ddrescue version 1.18-pre6<br>
# Command line: ddrescue /dev/fd0 fdimage logfile<br>
# current_pos  current_status<br>
0x00120000     ?<br>
#      pos         size   status<br>
   <p><table summary=""><tr align="left"><td valign="top">0x00000000 </td><td valign="top">0x00117000 </td><td valign="top">+
<br></td></tr><tr align="left"><td valign="top">0x00117000 </td><td valign="top">0x00000200 </td><td valign="top">-
<br></td></tr><tr align="left"><td valign="top">0x00117200 </td><td valign="top">0x00001000 </td><td valign="top">/
<br></td></tr><tr align="left"><td valign="top">0x00118200 </td><td valign="top">0x00007E00 </td><td valign="top">*
<br></td></tr><tr align="left"><td valign="top">0x00120000 </td><td valign="top">0x00048000 </td><td valign="top">?
   <br></td></tr></table>

   <p>If you edit the file, you may use decimal, hexadecimal or octal values,
using the same syntax that integer constants in C++.

<div class="node">
<a name="Examples"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Direct-disc-access">Direct disc access</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Logfile-structure">Logfile structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 A small tutorial with examples</h2>

<p><a name="index-examples-10"></a>
This tutorial is for those already able to use the dd command. If you
don't know what dd is, better search the net for some introductory
material about dd and GNU ddrescue first.

   <p>A failing drive tends to develop more and more errors as time passes. 
Because of this, you should rescue the data from a drive as soon as you
notice the first error. Be diligent because every time a physically
damaged drive powers up and is able to output some data, it may be the
very last time that it ever will.

   <p>You should make a copy of the failing drive with ddrescue, and then try
to repair the copy. If your data is really important, use the first copy
as a master for a second copy, and try to repair the second copy. If
something goes wrong, you have the master intact to try again.

   <p>If you are trying to rescue a whole partition, first repair the copy
with e2fsck or some other tool appropiate for the type of partition you
are trying to rescue, then mount the repaired copy somewhere and try to
recover the files in it.

   <p>If the drive is so damaged that the file system in the rescued partition
can't be repaired or mounted, you will have to browse the rescued data
with an hex editor and extract the desired parts by hand or use a file
recovery tool like photorec.

   <p>If the partition table is damaged, you may try to rescue the whole disc,
then try to repair the partition table and the partitions on the copy.

   <p>If the damaged drive is not listed in /dev, then you cannot rescue it. 
At least not with ddrescue.

   <pre class="sp">

</pre>
Example 1: Rescue a whole disc with two ext2 partitions in /dev/hda to
/dev/hdb.<br>
Note: you do not need to partition /dev/hdb beforehand, but if the
partition table on /dev/hda is damaged, you'll need to recreate it
somehow on /dev/hdb.

<pre class="example">     ddrescue -f -n /dev/hda /dev/hdb logfile
     ddrescue -d -f -r3 /dev/hda /dev/hdb logfile
     fdisk /dev/hdb
     e2fsck -v -f /dev/hdb1
     e2fsck -v -f /dev/hdb2
</pre>
   <pre class="sp">

</pre>
Example 2: Rescue an ext2 partition in /dev/hda2 to /dev/hdb2.<br>
Note: you need to create the hdb2 partition with fdisk first. hdb2
should be of appropiate type and size.

<pre class="example">     ddrescue -f -n /dev/hda2 /dev/hdb2 logfile
     ddrescue -d -f -r3 /dev/hda2 /dev/hdb2 logfile
     e2fsck -v -f /dev/hdb2
     mount -t ext2 -o ro /dev/hdb2 /mnt
       (read rescued files from /mnt)
</pre>
   <pre class="sp">

</pre>
Example 3: Rescue a CD-ROM in /dev/cdrom.

<pre class="example">     ddrescue -n -b2048 /dev/cdrom cdimage logfile
     ddrescue -d -b2048 /dev/cdrom cdimage logfile
       (if errsize is zero, cdimage now contains a complete image of the
        CD-ROM and you can write it to a blank CD-ROM)
</pre>
   <pre class="sp">

</pre>
Example 4: Rescue a CD-ROM in /dev/cdrom from two copies.

<pre class="example">     ddrescue -n -b2048 /dev/cdrom cdimage logfile
     ddrescue -d -b2048 /dev/cdrom cdimage logfile
       (insert second copy in the CD drive)
     ddrescue -d -r1 -b2048 /dev/cdrom cdimage logfile
       (if errsize is zero, cdimage now contains a complete image of the
        CD-ROM and you can write it to a blank CD-ROM)
</pre>
   <pre class="sp">

</pre>
Example 5: Merge the partially recovered images of 3 identical DVDs
using their logfiles as domain logfiles.

<pre class="example">     ddrescue -m logfile1 dvdimage1 dvdimage logfile
     ddrescue -m logfile2 dvdimage2 dvdimage logfile
     ddrescue -m logfile3 dvdimage3 dvdimage logfile
       (if errsize is zero, dvdimage now contains a complete image of the DVD
        and you can write it to a blank DVD)
</pre>
   <pre class="sp">

</pre>
<a name="lziprecover_002dexample"></a>Example 6: Rescue a lzip compressed backup from two copies on CD-ROM
with error-checked merging of copies
(See the
<a href="http://www.nongnu.org/lzip/manual/lziprecover_manual.html">lziprecover manual</a>
for details about lziprecover).

<pre class="example">     ddrescue -b2048 /dev/cdrom cdimage1 logfile1
     mount -t iso9660 -o loop,ro cdimage1 /mnt/cdimage
     cp /mnt/cdimage/backup.tar.lz rescued1.tar.lz
     umount /mnt/cdimage
       (insert second copy in the CD drive)
     ddrescue -b2048 /dev/cdrom cdimage2 logfile2
     mount -t iso9660 -o loop,ro cdimage2 /mnt/cdimage
     cp /mnt/cdimage/backup.tar.lz rescued2.tar.lz
     umount /mnt/cdimage
     lziprecover -m -v -o backup.tar.lz rescued1.tar.lz rescued2.tar.lz
</pre>
   <pre class="sp">

</pre>
Example 7: While rescuing the whole drive /dev/hda to /dev/hdb, /dev/hda
freezes up at position 12345678.

<pre class="example">     ddrescue -f /dev/hda /dev/hdb logfile       &lt;-- /dev/hda freezes here
       (restart /dev/hda or reboot computer)
       (restart copy at a safe distance from the troubled sector)
     ddrescue -f -i 12350000 /dev/hda /dev/hdb logfile
       (copy backwards down to the troubled sector)
     ddrescue -f -R /dev/hda /dev/hdb logfile
</pre>
   <pre class="sp">

</pre>
Example 8: While rescuing the whole drive /dev/hda to /dev/hdb, /dev/hdb
fails and you have to rescue data to a third drive, /dev/hdc.

<pre class="example">     ddrescue -f -n /dev/hda /dev/hdb logfile1     &lt;-- /dev/hdb fails here
     ddrescue -f -m logfile1 /dev/hdb /dev/hdc logfile2
     ddrescue -f -n /dev/hda /dev/hdc logfile2
     ddrescue -d -f -r3 /dev/hda /dev/hdc logfile2
</pre>
   <pre class="sp">

</pre>
Example 9: While rescuing the whole drive /dev/hda to /dev/hdb, /dev/hda
stops responding and disappears from /dev.

<pre class="example">     ddrescue -f -n /dev/hda /dev/hdb logfile      &lt;-- /dev/hda fails here
       (restart /dev/hda or reboot computer as many times as needed)
     ddrescue -f -n -A /dev/hda /dev/hdb logfile
     ddrescue -d -f -r3 /dev/hda /dev/hdb logfile
</pre>
   <div class="node">
<a name="Direct-disc-access"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Fill-mode">Fill mode</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Examples">Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Direct disc access</h2>

<p><a name="index-direct-disc-access-11"></a><a name="index-raw-devices-12"></a>
If you notice that the positions and sizes in the logfile are ALWAYS
multiples of the sector size, maybe your kernel is caching the disc
accesses and grouping them. In this case you may want to use direct disc
access or a raw device to bypass the kernel cache and rescue more of
your data.

   <p>NOTE! Sector size must be correctly set with the '<samp><span class="samp">--sector-size</span></samp>'
option for this to work. Only whole sectors can be read; both
'<samp><span class="samp">--input-position</span></samp>' and '<samp><span class="samp">--size</span></samp>' must be a multiple of sector
size.

   <p>Try the '<samp><span class="samp">--direct</span></samp>' option first. If direct disc access is not
available in your system, try raw devices. Read your system
documentation to find how to bind a raw device to a regular block
device. Some OSs provide raw access through special device names, like
/dev/rdisk.

   <p>Ddrescue aligns its I/O buffer to the sector size so that it can be used
for direct disc access or to read from raw devices. For efficiency
reasons, also aligns it to the memory page size if page size is a
multiple of sector size. On some systems, ddrescue can't determine the
size of a raw device, so an explicit '<samp><span class="samp">--size</span></samp>' or
'<samp><span class="samp">--complete-only</span></samp>' option may be needed.

   <p>Using direct disc access, or reading from a raw device, may be slower or
faster than normal cached reading depending on your OS and hardware. In
case it is slower you may want to make a first pass using normal cached
reads and use direct disc access, or a raw device, only to recover the
good sectors inside the failed blocks.

   <pre class="sp">

</pre>
Example 1: using direct disc access.

<pre class="example">     ddrescue -f -n /dev/hdb1 /dev/hdc1 logfile
     ddrescue -d -f -r3 /dev/hdb1 /dev/hdc1 logfile
     e2fsck -v -f /dev/hdc1
     mount -t ext2 -o ro /dev/hdc1 /mnt
</pre>
   <pre class="sp">

</pre>
Example 2: using a raw device.

<pre class="example">     raw /dev/raw/raw1 /dev/hdb1
     ddrescue -f -n /dev/hdb1 /dev/hdc1 logfile
     ddrescue -C -f -r3 /dev/raw/raw1 /dev/hdc1 logfile
     raw /dev/raw/raw1 0 0
     e2fsck -v -f /dev/hdc1
     mount -t ext2 -o ro /dev/hdc1 /mnt
</pre>
   <div class="node">
<a name="Fill-mode"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Generate-mode">Generate mode</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Direct-disc-access">Direct disc access</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Fill mode</h2>

<p><a name="index-fill-Mode-13"></a>
When ddrescue is invoked with the '<samp><span class="samp">--fill-mode</span></samp>' option it operates
in "fill mode", which is different from the default "rescue mode". That
is, if you use the '<samp><span class="samp">--fill-mode</span></samp>' option, ddrescue does not rescue
anything. It only fills with data read from the input file the blocks of
the output file whose status character from the logfile coincides with
one of the type characters specified as argument to the
'<samp><span class="samp">--fill-mode</span></samp>' option.

   <p>In fill mode the input file may have any size. If it is too small, the
data will be duplicated as many times as necessary to fill the input
buffer. If it is too big, only the data needed to fill the input buffer
will be read. Then the same data will be written to every cluster or
sector to be filled.

   <p>Note that in fill mode the input file is always read from position 0. If
you specify a '<samp><span class="samp">--input-position</span></samp>', it refers to the original input
file from which the logfile was built, and is only used to calculate the
offset between input and output positions.

   <p>Note also that when filling the input file of the original rescue run
you should set '<samp><span class="samp">--input-position</span></samp>' and '<samp><span class="samp">--output-position</span></samp>' to
identical values, whereas when filling the output file of the original
rescue run you should keep the original offset between
'<samp><span class="samp">--input-position</span></samp>' and '<samp><span class="samp">--output-position</span></samp>'.

   <p>The '<samp><span class="samp">--fill-mode</span></samp>' option implies the '<samp><span class="samp">--complete-only</span></samp>' option.

   <p>In fill mode the logfile is updated to allow resumability when
interrupted or in case of a crash, but as nothing is being rescued the
logfile is not destroyed. The status line is the only part of the
logfile that is modified.

   <pre class="sp">

</pre>
The fill mode has a number of uses. See the following examples:

<p class="noindent">Example 1: Mark parts of the rescued copy to allow finding them when
examined in an hex editor. For example, the following command line fills
all blocks marked as '<samp><span class="samp">-</span></samp>' (bad-sector) with copies of the string
'<samp><span class="samp">BAD&nbsp;SECTOR&nbsp;</span></samp>'<!-- /@w -->:

<pre class="example">     printf "BAD SECTOR " &gt; tmpfile
     ddrescue --fill-mode=- tmpfile outfile logfile
</pre>
   <p class="noindent">Example 2: Wipe only the good sectors, leaving the bad sectors alone. 
This way, the drive will still test bad (i.e., with unreadable sectors). 
This is the fastest way of wiping a failing drive, and is specially
useful when sending the drive back to the manufacturer for warranty
replacement.

<pre class="example">     ddrescue --fill-mode=+ --force /dev/zero bad_drive logfile
</pre>
   <p class="noindent">Example 3: Force the drive to remap the bad sectors, making it usable
again. If the drive has only a few bad sectors, and they are not caused
by drive age, you can probably just rewrite those sectors, and the drive
will reallocate them automatically to new "spare" sectors that it keeps
for just this purpose. WARNING! This may not work on your drive.

<pre class="example">     ddrescue --fill-mode=- --force --synchronous /dev/zero bad_drive logfile
</pre>
   <pre class="sp">

</pre>
Fill mode can also help you to figure out, independently of the file
system used, what files are partially or entirely in the bad areas of
the disc. Just follow these steps:

   <p>1) Copy the damaged drive with ddrescue until finished. Do not use
sparse writes. This yields a logfile with only finished ('<samp><span class="samp">+</span></samp>') and
bad-sector ('<samp><span class="samp">-</span></samp>') blocks.

   <p>2) Fill the bad-sector blocks of the copied drive or image file with a
string not present in any file, for example "DEADBEEF".

   <p>3) Mount the copied drive (or the image file, via loopback device).

   <p>4) Grep for the fill string in all the files. Those files containing the
string reside (at least partially) in damaged disc areas.

   <p>5) Unmount the copied drive or image file.

   <p>6) Optionally fill the bad-sector blocks of the copied drive or image
file with zeros to restore the disc image.

<p class="noindent">Example 4: Figure out what files are in the bad areas of the disc.

<pre class="example">     ddrescue -b2048 /dev/cdrom cdimage logfile
     printf "DEADBEEF" &gt; tmpfile
     ddrescue --fill-mode=- tmpfile cdimage logfile
     rm tmpfile
     mount -t iso9660 -o loop,ro cdimage /mnt/cdimage
     find /mnt/cdimage -type f -exec grep "DEADBEEF" '{}' ';'
     umount /mnt/cdimage
     ddrescue --fill-mode=- /dev/zero cdimage logfile
</pre>
   <div class="node">
<a name="Generate-mode"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ddrescuelog">Ddrescuelog</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fill-mode">Fill mode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Generate mode</h2>

<p><a name="index-generate-Mode-14"></a>
NOTE: When ddrescue is invoked with the '<samp><span class="samp">--generate-mode</span></samp>' option it
operates in "generate mode", which is different from the default "rescue
mode". That is, if you use the '<samp><span class="samp">--generate-mode</span></samp>' option, ddrescue
does not rescue anything. It only tries to generate a logfile for later
use.

   <p>So you didn't read the tutorial and started ddrescue without a logfile. 
Now, two days later, your computer crashed and you can't know how much
data ddrescue managed to save. And even worse, you can't resume the
rescue; you have to restart it from the very beginning.

   <p>Or maybe you started copying a drive with <code>dd&nbsp;conv=noerror,sync</code><!-- /@w --> and are now in the same situation described above. 
In this case, note that you can't use a copy made by dd unless it was
invoked with the '<samp><span class="samp">sync</span></samp>' conversion argument.

   <p>Don't despair (yet). Ddrescue can in some cases generate an approximate
logfile, from the input file and the (partial) copy, that is almost as
good as an exact logfile. It makes this by simply assuming that sectors
containing all zeros were not rescued.

   <p>However, if the destination of the copy was a drive or a partition, (or
an existing regular file and truncation was not requested), most
probably you will need to restart ddrescue from the very beginning. 
(This time with a logfile, of course). The reason is that old data may
be present in the drive that have not been overwritten yet, and may be
thus non-tried but non-zero.

   <p>For example, if you first tried one of these commands:
<pre class="example">     ddrescue infile outfile
     or
     dd if=infile of=outfile conv=noerror,sync
</pre>
   <p>then you can generate an approximate logfile with this command:
<pre class="example">     ddrescue --generate-mode infile outfile logfile
</pre>
   <p class="noindent">Note that you must keep the original offset between
'<samp><span class="samp">--input-position</span></samp>' and '<samp><span class="samp">--output-position</span></samp>' of the original
rescue run.

<div class="node">
<a name="Ddrescuelog"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invoking-ddrescuelog">Invoking ddrescuelog</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Generate-mode">Generate mode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 Ddrescuelog</h2>

<p><a name="index-ddrescuelog-15"></a>
Ddrescuelog is a tool that manipulates ddrescue logfiles, shows logfile
contents, converts logfiles to/from other formats, compares logfiles,
tests rescue status, and can delete a logfile if the rescue is done. 
Ddrescuelog operations can be restricted to one or several parts of the
logfile if the domain setting options are used.

   <p>Here are some examples of how to use ddrescuelog, alone or in
combination with other tools.

   <pre class="sp">

</pre>
Example 1: Delete the logfile if the rescue is finished (all data is
recovered without errors left).

<pre class="example">     ddrescue -f /dev/hda /dev/hdb logfile
     ddrescuelog -d logfile
</pre>
   <pre class="sp">

</pre>
Example 2: Rescue two ext2 partitions in /dev/hda to
/dev/hdb and repair the file systems using badblock lists generated with
ddrescuelog. File system block size is 4096.<br>
Note: you do need to partition /dev/hdb beforehand.

<pre class="example">     fdisk /dev/hdb                                &lt;-- partition /deb/hdb
     ddrescue -f /dev/hda1 /dev/hdb1 logfile1
     ddrescue -f /dev/hda2 /dev/hdb2 logfile2
     ddrescuelog -l- -b4096 logfile1 &gt; badblocks1
     ddrescuelog -l- -b4096 logfile2 &gt; badblocks2
     e2fsck -v -f -L badblocks1 /dev/hdb1
     e2fsck -v -f -L badblocks2 /dev/hdb2
</pre>
   <pre class="sp">

</pre>
Example 3: Rescue a whole disc with two ext2 partitions in /dev/hda to
/dev/hdb and repair the file systems using badblock lists generated with
ddrescuelog. Disc sector size is 512, file system block size is 4096. 
Arguments to options '<samp><span class="samp">-i</span></samp>' and '<samp><span class="samp">-s</span></samp>' are the starting positions
and sizes of the partitions being rescued.<br>
Note: you do not need to partition /dev/hdb beforehand, but if the
partition table on /dev/hda is damaged, you'll need to recreate it
somehow on /dev/hdb.

<pre class="example">     ddrescue -f /dev/hda /dev/hdb logfile
     fdisk /dev/hdb                                &lt;-- get partition sizes
     ddrescuelog -l- -b512 -i63b -o0 -s9767457b -b4096 logfile &gt; badblocks1
     ddrescuelog -l- -b512 -i9767520b -o0 -s128520b -b4096 logfile &gt; badblocks2
     e2fsck -v -f -L badblocks1 /dev/hdb1
     e2fsck -v -f -L badblocks2 /dev/hdb2
</pre>
   <div class="node">
<a name="Invoking-ddrescuelog"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Problems">Problems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ddrescuelog">Ddrescuelog</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">12 Invoking ddrescuelog</h2>

<p><a name="index-invoking-ddrescuelog-16"></a>
The format for running ddrescuelog is:

<pre class="example">     ddrescuelog [<var>options</var>] <var>logfile</var>
</pre>
   <p>Ddrescuelog supports the following options:

     <dl>
<dt>'<samp><span class="samp">-h</span></samp>'<dt>'<samp><span class="samp">--help</span></samp>'<dd>Print an informative help message describing the options and exit.

     <br><dt>'<samp><span class="samp">-V</span></samp>'<dt>'<samp><span class="samp">--version</span></samp>'<dd>Print the version number of ddrescuelog on the standard output and exit.

     <br><dt>'<samp><span class="samp">-a </span><var>old_types</var><span class="samp">,</span><var>new_types</var></samp>'<dt>'<samp><span class="samp">--change-types=</span><var>old_types</var><span class="samp">,</span><var>new_types</var></samp>'<dd>Change the status of every block in the rescue domain from one type in
<var>old_types</var> to the corresponding type in <var>new_types</var>, much like
the '<samp><span class="samp">tr</span></samp>' command does, and write the resulting logfile to standard
output. <var>old_types</var> and <var>new_types</var> are strings of block status
characters as defined in the chapter Logfile structure (see <a href="#Logfile-structure">Logfile structure</a>). Blocks whose status is not in <var>old_types</var> are left
unchanged. If <var>new_types</var> is shorter than <var>old_types</var> the last
type of <var>new_types</var> is repeated as many times as necessary.

     <br><dt>'<samp><span class="samp">-b </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--block-size=</span><var>bytes</var></samp>'<dd>Block size used by ddrescuelog. Depending on the requested operation it
may be the sector size of the input device, the block size of the
rescued file system, etc. Defaults to 512.

     <br><dt>'<samp><span class="samp">-B</span></samp>'<dt>'<samp><span class="samp">--binary-prefixes</span></samp>'<dd>Show units with binary prefixes (powers of 1024).<br>
SI prefixes (powers of 1000) are used by default. (See table above,
<a href="#Invoking-ddrescue">Invoking ddrescue</a>).

     <br><dt>'<samp><span class="samp">-c[</span><var>type1</var><var>type2</var><span class="samp">]</span></samp>'<dt>'<samp><span class="samp">--create-logfile[=</span><var>type1</var><var>type2</var><span class="samp">]</span></samp>'<dd>Create a logfile from a list of block numbers read from standard input. 
Only blocks included in the rescue domain will be added to <var>logfile</var>.

     <p><var>type1</var> and <var>type2</var> are block status characters as defined in
the chapter Logfile structure (see <a href="#Logfile-structure">Logfile structure</a>). <var>type1</var>
sets the type for blocks included in the list, while <var>type2</var> sets
the type for the rest of the logfile. If not specified, <var>type1</var>
defaults to '<samp><span class="samp">+</span></samp>' and <var>type2</var> defaults to '<samp><span class="samp">-</span></samp>'.

     <br><dt>'<samp><span class="samp">-C[</span><var>type</var><span class="samp">]</span></samp>'<dt>'<samp><span class="samp">--complete-logfile[=</span><var>type</var><span class="samp">]</span></samp>'<dd>Complete a synthetic (user fabricated) <var>logfile</var> by filling the gaps
with blocks of type <var>type</var>, and write the completed logfile to
standard output. <var>type</var> is one of the block status characters
defined in the chapter Logfile structure (see <a href="#Logfile-structure">Logfile structure</a>). If
<var>type</var> is not specified, the gaps are filled with non-tried blocks. 
All gaps in the logfile are filled. Domain options are ignored.

     <br><dt>'<samp><span class="samp">-d</span></samp>'<dt>'<samp><span class="samp">--delete-if-done</span></samp>'<dd>Delete the given <var>logfile</var> if all the blocks in the rescue domain
have been successfuly recovered. The exit status is 0 if <var>logfile</var>
could be deleted, 1 otherwise.

     <br><dt>'<samp><span class="samp">-D</span></samp>'<dt>'<samp><span class="samp">--done-status</span></samp>'<dd>Test if all the blocks in the rescue domain have been successfuly
recovered. The exit status is 0 if all tested blocks are finished, 1
otherwise.

     <br><dt>'<samp><span class="samp">-f</span></samp>'<dt>'<samp><span class="samp">--force</span></samp>'<dd>Force overwrite of <var>logfile</var>.

     <br><dt>'<samp><span class="samp">-i </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--input-position=</span><var>bytes</var></samp>'<dd>Starting position of the rescue domain, in bytes. Defaults to 0. It
refers to a position in the original input file.

     <br><dt>'<samp><span class="samp">-l </span><var>types</var></samp>'<dt>'<samp><span class="samp">--list-blocks=</span><var>types</var></samp>'<dd>Print on standard output the block numbers of the blocks specified as
any of <var>types</var> in <var>logfile</var> and included in the rescue domain. 
<var>types</var> contains one or more of the block status characters defined
in the chapter Logfile structure (see <a href="#Logfile-structure">Logfile structure</a>).

     <p>The list format is one block number per line in decimal, like the output
of the badblocks program, so that it can be used as input for e2fsck or
other similar filesystem repairing tool.

     <br><dt>'<samp><span class="samp">-L</span></samp>'<dt>'<samp><span class="samp">--loose-domain</span></samp>'<dd>Accept a incomplete synthetic (user fabricated) domain logfile and fill
the gaps with non-tried blocks. The blocks in the logfile must be
strictly ascending and non-overlapping, but they do not need to be
contiguous. This option allows making quick edits to a logfile without
all the size calculations involved in making all data blocks contiguous
again.

     <br><dt>'<samp><span class="samp">-m </span><var>file</var></samp>'<dt>'<samp><span class="samp">--domain-logfile=</span><var>file</var></samp>'<dd>Restrict the rescue domain to the blocks marked as finished in the
logfile <var>file</var>.

     <br><dt>'<samp><span class="samp">-n</span></samp>'<dt>'<samp><span class="samp">--invert-logfile</span></samp>'<dd>Invert the types of the blocks in <var>logfile</var> which are included in
the rescue domain, and write the resulting logfile to standard output. 
Finished blocks ('<samp><span class="samp">+</span></samp>') are changed to bad-sector ('<samp><span class="samp">-</span></samp>'), all
other types are changed to finished. '<samp><span class="samp">--invert-logfile</span></samp>' is
equivalent to '<samp><span class="samp">--change-types=?*/-+,++++-</span></samp>'

     <br><dt>'<samp><span class="samp">-o </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--output-position=</span><var>bytes</var></samp>'<dd>Starting position in output file, in bytes. Is used by the
'<samp><span class="samp">--list-blocks</span></samp>' option. Defaults to '<samp><span class="samp">--input-position</span></samp>'.

     <br><dt>'<samp><span class="samp">-p </span><var>file</var></samp>'<dt>'<samp><span class="samp">--compare-logfile=</span><var>file</var></samp>'<dd>Compare the types of the blocks included in the rescue domain. The exit
status is 0 if all tested blocks are the same in both files, 1
otherwise.

     <br><dt>'<samp><span class="samp">-q</span></samp>'<dt>'<samp><span class="samp">--quiet</span></samp>'<dd>Quiet operation. Suppress all messages.

     <br><dt>'<samp><span class="samp">-s </span><var>bytes</var></samp>'<dt>'<samp><span class="samp">--size=</span><var>bytes</var></samp>'<dd>Maximum size of the rescue domain, in bytes. It refers to a size in the
original input file.

     <br><dt>'<samp><span class="samp">-t</span></samp>'<dt>'<samp><span class="samp">--show-status</span></samp>'<dd>Print a summary of <var>logfile</var> contents on the standard output. The
summary can be restricted to one or several parts of <var>logfile</var> if
the domain setting options are used.

     <br><dt>'<samp><span class="samp">-v</span></samp>'<dt>'<samp><span class="samp">--verbose</span></samp>'<dd>Verbose mode. Further -v's (up to 4) increase the verbosity level.

     <br><dt>'<samp><span class="samp">-x </span><var>file</var></samp>'<dt>'<samp><span class="samp">--xor-logfile=</span><var>file</var></samp>'<dd>Perform a logical XOR (exclusive OR) operation between the finished
blocks in <var>file</var> and those in <var>logfile</var>, and write the resulting
logfile to standard output. In other words, in the resulting logfile a
block is only shown as finished if it was finished in either of the two
input logfiles but not in both.

     <br><dt>'<samp><span class="samp">-y </span><var>file</var></samp>'<dt>'<samp><span class="samp">--and-logfile=</span><var>file</var></samp>'<dd>Perform a logical AND operation between the finished blocks in
<var>file</var> and those in <var>logfile</var>, and write the resulting logfile
to standard output. In other words, in the resulting logfile a block is
only shown as finished if it was finished in both input logfiles.

     <br><dt>'<samp><span class="samp">-z </span><var>file</var></samp>'<dt>'<samp><span class="samp">--or-logfile=</span><var>file</var></samp>'<dd>Perform a logical OR operation between the finished blocks in <var>file</var>
and those in <var>logfile</var>, and write the resulting logfile to standard
output. In other words, in the resulting logfile a block is shown as
finished if it was finished in either of the two input logfiles.

   </dl>

   <p>Exit status: 0 for a normal exit, 1 for environmental problems (file not
found, invalid flags, I/O errors, etc), 2 to indicate a corrupt or
invalid input file, 3 for an internal consistency error (eg, bug) which
caused ddrescuelog to panic.

<div class="node">
<a name="Problems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-index">Concept index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Invoking-ddrescuelog">Invoking ddrescuelog</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">13 Reporting bugs</h2>

<p><a name="index-bugs-17"></a><a name="index-getting-help-18"></a>
There are probably bugs in ddrescue. There are certainly errors and
omissions in this manual. If you report them, they will get fixed. If
you don't, no one will ever know about them and they will remain unfixed
for all eternity, if not longer.

   <p>If you find a bug in GNU ddrescue, please send electronic mail to
<a href="mailto:bug-ddrescue@gnu.org">bug-ddrescue@gnu.org</a>. Include the version number, which you can
find by running '<samp><span class="samp">ddrescue&nbsp;--version</span></samp>'<!-- /@w -->.

<div class="node">
<a name="Concept-index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Problems">Problems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept index</h2>

<ul class="index-cp" compact>
<li><a href="#index-algorithm-4">algorithm</a>: <a href="#Algorithm">Algorithm</a></li>
<li><a href="#index-basic-concepts-2">basic concepts</a>: <a href="#Basic-concepts">Basic concepts</a></li>
<li><a href="#index-bugs-17">bugs</a>: <a href="#Problems">Problems</a></li>
<li><a href="#index-ddrescuelog-15">ddrescuelog</a>: <a href="#Ddrescuelog">Ddrescuelog</a></li>
<li><a href="#index-direct-disc-access-11">direct disc access</a>: <a href="#Direct-disc-access">Direct disc access</a></li>
<li><a href="#index-examples-10">examples</a>: <a href="#Examples">Examples</a></li>
<li><a href="#index-fill-Mode-13">fill Mode</a>: <a href="#Fill-mode">Fill mode</a></li>
<li><a href="#index-generate-Mode-14">generate Mode</a>: <a href="#Generate-mode">Generate mode</a></li>
<li><a href="#index-getting-help-18">getting help</a>: <a href="#Problems">Problems</a></li>
<li><a href="#index-introduction-1">introduction</a>: <a href="#Introduction">Introduction</a></li>
<li><a href="#index-invoking-ddrescue-5">invoking ddrescue</a>: <a href="#Invoking-ddrescue">Invoking ddrescue</a></li>
<li><a href="#index-invoking-ddrescuelog-16">invoking ddrescuelog</a>: <a href="#Invoking-ddrescuelog">Invoking ddrescuelog</a></li>
<li><a href="#index-logfile-structure-9">logfile structure</a>: <a href="#Logfile-structure">Logfile structure</a></li>
<li><a href="#index-options-6">options</a>: <a href="#Invoking-ddrescue">Invoking ddrescue</a></li>
<li><a href="#index-raw-devices-12">raw devices</a>: <a href="#Direct-disc-access">Direct disc access</a></li>
<li><a href="#index-usage-7">usage</a>: <a href="#Invoking-ddrescue">Invoking ddrescue</a></li>
<li><a href="#index-using-ddrescue-safely-3">using ddrescue safely</a>: <a href="#Important-advice">Important advice</a></li>
<li><a href="#index-version-8">version</a>: <a href="#Invoking-ddrescue">Invoking ddrescue</a></li>
</ul></body></html>

<!--

Local Variables:
coding: iso-8859-15
End:

-->
